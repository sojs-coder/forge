import { getLineSegmentsIntersection } from "../../Math/LineIntersections";
import { Vector } from "../../Math/Vector";
import { vecEq, pointInPoly } from "../../helpers";
import type { Camera } from "../Camera";
import { Game } from "../Game";
import { Part } from "../Part";
import type { Transform } from "./Transform";

export abstract class Collider extends Part {
    colliding: boolean = false;
    collidingWith: Set<Collider> = new Set();
    tag: string = "";
    radius: number;
    realWorldStart: Vector;
    realWorldEnd: Vector;
    vertices: Vector[];
    active: boolean = true;
    allowMerge: boolean;
    randomTestingColors: [number, number, number];
    constructor({ tag, allowMerge }: { tag?: string, allowMerge?: boolean }) {
        super({ name: "Collider" });
        this.type = "Collider";
        this.base = "Collider";
        this.tag = tag || "<Untagged>";
        this.radius = 0;
        this.realWorldStart = new Vector(0, 0);
        this.allowMerge = allowMerge !== undefined ? allowMerge : true;
        this.realWorldEnd = new Vector(0, 0);
        this.randomTestingColors = [
            Math.random() * 255,
            Math.random() * 255,
            Math.random() * 255
        ];
        this.vertices = [];
    }

    setTag(tag: string) {
        this.tag = tag;
    }

    abstract override clone(memo?: Map<Part, Part>): this;

    onMount(parent: Part) {
        super.onMount(parent);
        const transform = this.sibling<Transform>("Transform");
        if (!transform) {
            this.top?.warn(
                `Collider <${this.name}> (${this.id}) does not have Transform sibling. Please ensure you add a Transform component.`
            );
            return;
        }
        this.updateCollider(transform);
    }

    abstract get worldVertices(): Vector[];

    abstract narrowPhaseCheck(other: Collider): boolean;

    abstract updateCollider(transform: Transform): void;

    abstract drawDebug(ctx: CanvasRenderingContext2D): void;

    abstract _updateVerticesAfterMerge(vertices: Vector[]): void;

    private isMergedAndConcave: boolean = false;
    private convexParts: Vector[][] = [];

    private isConvex(vertices: Vector[]): boolean {
        if (vertices.length < 4) return true;
        let sign = 0;
        for (let i = 0; i < vertices.length; i++) {
            const p1 = vertices[i];
            const p2 = vertices[(i + 1) % vertices.length];
            const p3 = vertices[(i + 2) % vertices.length];
            const crossProduct = (p2.x - p1.x) * (p3.y - p2.y) - (p2.y - p1.y) * (p3.x - p2.x);
            if (Math.abs(crossProduct) > 1e-9) {
                if (sign === 0) {
                    sign = Math.sign(crossProduct);
                } else if (Math.sign(crossProduct) !== sign) {
                    return false;
                }
            }
        }
        return true;
    }

    private triangulate(vertices: Vector[]): Vector[][] {
        const triangles: Vector[][] = [];
        const polygon = [...vertices];
    
        while (polygon.length > 3) {
            let earFound = false;
            for (let i = 0; i < polygon.length; i++) {
                const p1 = polygon[(i + polygon.length - 1) % polygon.length];
                const p2 = polygon[i];
                const p3 = polygon[(i + 1) % polygon.length];
    
                const crossProduct = (p2.x - p1.x) * (p3.y - p2.y) - (p2.y - p1.y) * (p3.x - p2.x);
    
                if (crossProduct < 0) continue;
    
                const triangle = [p1, p2, p3];
                let isEar = true;
    
                for (let j = 0; j < polygon.length; j++) {
                    if (j === i || j === (i + 1) % polygon.length || j === (i + polygon.length - 1) % polygon.length) continue;
                    if (pointInPoly(polygon[j], triangle)) {
                        isEar = false;
                        break;
                    }
                }
    
                if (isEar) {
                    triangles.push(triangle);
                    polygon.splice(i, 1);
                    earFound = true;
                    break;
                }
            }
            if (!earFound) {
                break;
            }
        }
        if (polygon.length === 3) {
            triangles.push(polygon);
        }
        return triangles;
    }

    onRegister(attribute: string, value: any) {
        super.onRegister(attribute, value);
        if (attribute === "layer") {
            value.flats.colliders.push(this);
        }
    }


    evaluateMerging() {
        const layer = this.registrations["layer"];
        if (!layer) return;

        const fellowColliders = layer.flats.colliders.filter((c: Collider) => c.tag == this.tag && c.id !== this.id && c.allowMerge && c.active);
        if (fellowColliders.length == 0) return;

        for (const fellow of fellowColliders) {
            if (this.id < fellow.id && this.checkCollision(fellow, true)) {
                this.mergeWith(fellow);
            }
        }
    }
    onStart() {
        if (this.allowMerge) this.evaluateMerging();
    }

    mergeWith(other: Collider) {
        if (this.tag !== other.tag || other.tag == "<Untagged>" || this.tag == "<Untagged>") return;

        const thisTransform = this.sibling<Transform>("Transform");
        if (!thisTransform) {
            this.top?.warn(`Collider <${this.name}> has no Transform sibling, cannot merge.`);
            return;
        }

        const poly1 = this.worldVertices;
        const poly2 = other.worldVertices;

        // --- Conservative Merge Check ---
        let sharedEdges = 0;
        const tolerance = 1e-5;

        for (let i = 0; i < poly1.length; i++) {
            const p1_v1 = poly1[i];
            const p1_v2 = poly1[(i + 1) % poly1.length];
            for (let j = 0; j < poly2.length; j++) {
                const p2_v1 = poly2[j];
                const p2_v2 = poly2[(j + 1) % poly2.length];
                if (p1_v1.distance(p2_v2) < tolerance && p1_v2.distance(p2_v1) < tolerance) {
                    sharedEdges++;
                }
            }
        }

        if (sharedEdges === 0) return; // Not adjacent, abort merge

        for(const p of poly1) {
            if(pointInPoly(p, poly2) && !poly2.some(p2 => p.distance(p2) < tolerance)) return;
        }
        for(const p of poly2) {
            if(pointInPoly(p, poly1) && !poly1.some(p1 => p.distance(p1) < tolerance)) return;
        }

        // --- Edge Cancellation Merge ---
        const getEdges = (vertices: Vector[]): Vector[][] => {
            const edges: Vector[][] = [];
            for (let i = 0; i < vertices.length; i++) {
                edges.push([vertices[i], vertices[(i + 1) % vertices.length]]);
            }
            return edges;
        };

        const allEdges = [...getEdges(poly1), ...getEdges(poly2)];
        const edgeMap = new Map<string, number>();
        const vecToKey = (v: Vector) => `${Math.round(v.x / tolerance)},${Math.round(v.y / tolerance)}`;

        for (const edge of allEdges) {
            const key = `${vecToKey(edge[0])}->${vecToKey(edge[1])}`;
            edgeMap.set(key, (edgeMap.get(key) || 0) + 1);
        }

        const finalEdges: Vector[][] = [];
        for (const [key, count] of edgeMap.entries()) {
            const [p1Key, p2Key] = key.split('->');
            const revKey = `${p2Key}->${p1Key}`;
            const revCount = edgeMap.get(revKey) || 0;
            if (count > revCount) {
                const edge = allEdges.find(e => vecToKey(e[0]) === p1Key && vecToKey(e[1]) === p2Key);
                if (edge) {
                    for (let i = 0; i < count - revCount; i++) {
                        finalEdges.push(edge);
                    }
                }
            }
        }

        if (finalEdges.length === 0) {
            other.inactivate();
            return;
        }

        const stitchMap = new Map<string, Vector>();
        for (const edge of finalEdges) {
            stitchMap.set(vecToKey(edge[0]), edge[1]);
        }

        const hull: Vector[] = [];
        let current = finalEdges[0][0];
        let startKey = vecToKey(current);

        for (let i = 0; i < finalEdges.length; i++) {
            hull.push(current);
            const currentKey = vecToKey(current);
            current = stitchMap.get(currentKey)!;
            if (vecToKey(current) === startKey) break;
        }

        if (hull.length < 3) {
            other.inactivate();
            return;
        }

        const newLocalVertices = hull.map(v => v.subtract(thisTransform.worldPosition));
        this._updateVerticesAfterMerge(newLocalVertices);

        if (!this.isConvex(newLocalVertices)) {
            this.isMergedAndConcave = true;
            this.convexParts = this.triangulate(newLocalVertices);
        }

        other.inactivate();
    }

    inactivate() {
        this.active = false;
    }
    activate() {
        this.active = true;
    }
    act(delta: number): void {
        super.act(delta);
        if (!this.active) return;
        if (!this.registrations?.layer) {
            throw new Error(`Collider <${this.name}> (${this.id}) is not registered to a layer. Collisions will not be checked.`);
        }

        const transform = this.sibling<Transform>("Transform");
        if (!transform) return;

        this.updateCollider(transform);
        this.colliding = false;
        this.collidingWith.clear();

        const layer = this.registrations.layer as Part;
        const colliders = layer.flats.colliders as Collider[];
        for (const other of colliders) {
            if (other === this) continue;
            if (this.checkCollision(other)) {
                this.colliding = true;
                this.collidingWith.add(other);
            }
        }

        this.hoverbug = `${this.colliding ? "ðŸŸ¥" : "ðŸŸ©"} - ${Array.from(this.collidingWith).map(o => o.name).join(", ")} objects`;

        // Debugging manually

        const fill = this.active;

        const ctx = this.top instanceof Game ? this.top.context : null;
        if (ctx) {
            ctx.beginPath();
            ctx.strokeStyle = `rgb(${this.randomTestingColors[0]}, ${this.randomTestingColors[1]}, ${this.randomTestingColors[2]})`;
            ctx.fillStyle = fill ? `rgba(${this.randomTestingColors[0]}, ${this.randomTestingColors[1]}, ${this.randomTestingColors[2]}, 0.5)` : "transparent";

            ctx.moveTo(this.worldVertices[0].x, this.worldVertices[0].y);
            for (const vertex of this.worldVertices) {
                ctx.lineTo(vertex.x, vertex.y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        }
        this.evaluateMerging();

        if (this.top instanceof Game && this.top.devmode) {
            const ctx = this.top.context;
            if (ctx) {
                this.drawDebug(ctx);
            }
        }
    }

    checkCollision(other: Collider, ignoreTags: boolean = false): boolean {
        const thisTransform = this.sibling<Transform>("Transform");
        const otherTransform = other.sibling<Transform>("Transform");

        if (!thisTransform || !otherTransform) {
            return false; // Cannot check collision without transforms
        }

        this.updateCollider(thisTransform);
        other.updateCollider(otherTransform);

        if (!this.active || !other.active) return false;

        if (!ignoreTags && other.tag === this.tag && this.tag !== "<Untagged>") return false;

        const checkParts = (collider: Collider, parts: Vector[][], transform: Transform, otherCollider: Collider) => {
            for (const part of parts) {
                const worldPart = part.map(p => p.add(transform.worldPosition));
                if (otherCollider.isMergedAndConcave) {
                    const otherTransform = otherCollider.sibling<Transform>("Transform")!;
                    for (const otherPart of otherCollider.convexParts) {
                        const otherWorldPart = otherPart.map(p => p.add(otherTransform.worldPosition));
                        if (this.checkVerticesAgainstVertices(worldPart, otherWorldPart)) return true;
                    }
                } else {
                    if (this.checkVerticesAgainstVertices(worldPart, otherCollider.worldVertices)) return true;
                }
            }
            return false;
        }

        if (this.isMergedAndConcave) {
            return checkParts(this, this.convexParts, thisTransform, other);
        }

        if (other.isMergedAndConcave) {
            return checkParts(other, other.convexParts, otherTransform, this);
        }

        if (
            this.realWorldEnd.x < other.realWorldStart.x ||
            this.realWorldStart.x > other.realWorldEnd.x ||
            this.realWorldEnd.y < other.realWorldStart.y ||
            this.realWorldStart.y > other.realWorldEnd.y
        ) {
            return false;
        }

        return this.narrowPhaseCheck(other);
    }

    isVisible(camera: Camera): boolean {
        if (!this.top) {
            throw new Error("Collider cannot calculate visibility without a 'top' (Game instance).");
        }

        const transform = this.sibling<Transform>("Transform");
        if (!transform) {
            return false;
        }
        this.updateCollider(transform);

        const { offset, scale } = camera.getViewMatrix();
        const cameraPos = offset.multiply(-1);

        const screenWidth = this.top.width;
        const screenHeight = this.top.height;

        const viewWidth = screenWidth / scale.x;
        const viewHeight = screenHeight / scale.y;

        const cameraVertices = [
            new Vector(cameraPos.x - viewWidth / 2, cameraPos.y - viewHeight / 2),
            new Vector(cameraPos.x + viewWidth / 2, cameraPos.y - viewHeight / 2),
            new Vector(cameraPos.x + viewWidth / 2, cameraPos.y + viewHeight / 2),
            new Vector(cameraPos.x - viewWidth / 2, cameraPos.y + viewHeight / 2)
        ];

        return this.checkVerticesAgainstVertices(this.worldVertices, cameraVertices);
    }

    protected checkVerticesAgainstVertices(vertices1: Vector[], vertices2: Vector[]): boolean {
        const axes1 = this.getAxes(vertices1);
        for (const axis of axes1) {
            const projection1 = this.project(vertices1, axis);
            const projection2 = this.project(vertices2, axis);

            if (!this.overlap(projection1, projection2)) {
                return false;
            }
        }

        const axes2 = this.getAxes(vertices2);
        for (const axis of axes2) {
            const projection1 = this.project(vertices1, axis);
            const projection2 = this.project(vertices2, axis);

            if (!this.overlap(projection1, projection2)) {
                return false;
            }
        }

        return true;
    }

    protected getAxes(vertices: Vector[]): Vector[] {
        const axes: Vector[] = [];
        for (let i = 0; i < vertices.length; i++) {
            const p1 = vertices[i];
            const p2 = vertices[i === vertices.length - 1 ? 0 : i + 1];
            const edge = p2.subtract(p1);
            const normal = new Vector(-edge.y, edge.x).normalize();
            axes.push(normal);
        }
        return axes;
    }

    protected project(vertices: Vector[], axis: Vector): { min: number, max: number } {
        let min = axis.dot(vertices[0]);
        let max = min;
        for (let i = 1; i < vertices.length; i++) {
            const p = axis.dot(vertices[i]);
            if (p < min) {
                min = p;
            } else if (p > max) {
                max = p;
            }
        }
        return { min, max };
    }

    protected overlap(proj1: { min: number, max: number }, proj2: { min: number, max: number }): boolean {
        return proj1.max >= proj2.min && proj2.max >= proj1.min;
    }
}