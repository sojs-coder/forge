# AnimatedSprite

**Extends:** [Renderer](./Renderer.md)

The `AnimatedSprite` component renders an animated sprite from a spritesheet. It requires a JSON file (typically generated by a tool like TexturePacker) that defines the frames and animations.

## Properties

-   `spritesheet: string`
    The path to the JSON file that defines the spritesheet data.

-   `currentAnimation: string`
    The name of the animation that is currently playing (e.g., "walk", "idle").

-   `onAnimationComplete?: (animationName: string, sprite: AnimatedSprite) => void`
    An optional callback function that is called when a non-looping animation finishes.

-   `width: number` & `height: number`
    The dimensions of the sprite. This should match the frame size defined in your spritesheet data.

## Methods

-   `setAnimation(animationName: string, { loop, bounce } = {})`
    Changes the current animation.
    -   `animationName`: The name of the animation to play.
    -   `loop`: (Optional) `true` to make the animation loop, `false` to play it once.
    -   `bounce`: (Optional) `true` to make the animation play forwards and then backwards.

## Spritesheet Format

The engine expects a specific JSON format for the spritesheet data. See the `convertTexturePackerToSpriteSheetData` helper function and the `SpriteSheetData` type in the source code for details.

## Examples

### Creating an Animated Sprite

```javascript
import { GameObject } from './Parts/GameObject';
import { Transform } from './Parts/Children/Transform';
import { AnimatedSprite } from './Parts/Children/AnimatedSprite';
import { Vector } from './Math/Vector';

const monster = new GameObject({ name: 'Monster' });

monster.addChildren(
    new Transform({ position: new Vector(400, 300) }),
    new AnimatedSprite({
        spritesheet: './assets/monster.json', // Path to the JSON data
        width: 32,
        height: 32,
        startingAnimation: 'walk'
    })
);

myLayer.addChild(monster);
```

### Controlling Animations from another Part

This example shows a script that changes the monster's animation based on its state.

```javascript
import { Part } from './Parts/Part';
import { AnimatedSprite } from './Parts/Children/AnimatedSprite';

class MonsterAI extends Part {
    constructor() {
        super();
        this.name = 'MonsterAI';
        this.isAngry = false;
    }

    act() {
        const animator = this.sibling<AnimatedSprite>('AnimatedSprite');
        if (!animator) return;

        // If the monster is angry and not already playing the attack animation...
        if (this.isAngry && animator.currentAnimation !== 'attack') {
            // Play the attack animation once, then call our onComplete function
            animator.setAnimation('attack', { loop: false });
            animator.onAnimationComplete = (animName, sprite) => {
                if (animName === 'attack') {
                    // After attacking, go back to idle
                    sprite.setAnimation('idle', { loop: true });
                    this.isAngry = false;
                }
            };
        } else if (!this.isAngry && animator.currentAnimation !== 'walk') {
            animator.setAnimation('walk', { loop: true });
        }
    }
}

// Add the AI to the monster GameObject
monster.addChild(new MonsterAI());
```
